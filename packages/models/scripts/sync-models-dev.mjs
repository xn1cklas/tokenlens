#!/usr/bin/env node
// Generate @tokenlens/models provider-scoped files from models.dev API
// Usage: node packages/models/scripts/sync-models-dev.mjs

import fs from "node:fs/promises";
import https from "node:https";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function fetchJson(url) {
  return new Promise((resolve, reject) => {
    https
      .get(url, (res) => {
        if (
          res.statusCode &&
          res.statusCode >= 300 &&
          res.statusCode < 400 &&
          res.headers.location
        ) {
          return resolve(fetchJson(res.headers.location));
        }
        if (res.statusCode !== 200)
          return reject(new Error(`Failed to fetch ${url}: ${res.statusCode}`));
        const chunks = [];
        res.on("data", (d) => chunks.push(d));
        res.on("end", () => {
          try {
            const body = Buffer.concat(chunks).toString("utf8");
            resolve(JSON.parse(body));
          } catch (e) {
            reject(e);
          }
        });
      })
      .on("error", reject);
  });
}

function mapProvider(providerKey, providerObj) {
  const models = providerObj.models || {};
  const mappedModels = {};
  for (const [modelId, m] of Object.entries(models)) {
    mappedModels[modelId] = {
      id: modelId,
      name: m.name || modelId,
      attachment: m.attachment,
      reasoning: m.reasoning,
      temperature: m.temperature,
      tool_call: m.tool_call,
      knowledge: m.knowledge,
      release_date: m.release_date,
      last_updated: m.last_updated,
      modalities: m.modalities,
      open_weights: m.open_weights,
      cost: m.cost,
      limit: m.limit,
    };
  }
  return {
    id: providerObj.id || providerKey,
    name: providerObj.name,
    api: providerObj.api,
    npm: providerObj.npm,
    doc: providerObj.doc || providerObj.docs,
    env: providerObj.env,
    source: "models.dev",
    schemaVersion: 1,
    models: mappedModels,
  };
}

function providerFileName(providerKey) {
  return providerKey.replace(/[^a-z0-9\-_.]/gi, "_");
}

// Create a safe JavaScript identifier for import/variable bindings (no dashes)
function importBindingName(providerKey) {
  return `${providerKey.replace(/[^a-zA-Z0-9_]/g, "_")}Provider`;
}

function toProviderTs(providerKey, providerInfo) {
  const varName = importBindingName(providerKey);
  const body = JSON.stringify(providerInfo, null, 2);
  return `export const ${varName} = ${body} as const;\nexport default ${varName};\n`;
}

async function main() {
  const url = "https://models.dev/api.json";
  const data = await fetchJson(url);
  const baseDir = path.join(__dirname, "..", "src", "modelsdev");
  const providersDir = path.join(baseDir, "providers");
  await fs.mkdir(providersDir, { recursive: true });

  const providerKeys = Object.keys(data).sort();
  const indexImports = [];
  const indexEntries = [];

  for (const key of providerKeys) {
    const providerInfo = mapProvider(key, data[key]);
    const fileBase = providerFileName(key);
    const filePath = path.join(providersDir, `${fileBase}.ts`);
    const ts = toProviderTs(key, providerInfo);
    await fs.writeFile(filePath, `${ts}\n`);
    const binding = importBindingName(key);
    indexImports.push(`import ${binding} from './providers/${fileBase}.js';`);
    indexEntries.push(`  ${JSON.stringify(key)}: ${binding},`);
  }

  const indexTs = `// Auto-generated by scripts/sync-models-dev.mjs
${indexImports.join("\n")}\n
export const modelsdevProviders = {\n${indexEntries.join("\n")}\n} as const;\n`;
  await fs.writeFile(path.join(baseDir, "index.ts"), `${indexTs}\n`);
  console.log(
    `Wrote ${providerKeys.length} models.dev provider files and index.ts`,
  );
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
