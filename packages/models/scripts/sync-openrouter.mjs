#!/usr/bin/env node
// Generate @tokenlens/models provider-scoped files from OpenRouter API
// Usage: node packages/models/scripts/sync-openrouter.mjs

import fs from "node:fs/promises";
import https from "node:https";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function fetchJson(url) {
  return new Promise((resolve, reject) => {
    https
      .get(url, (res) => {
        const chunks = [];
        res.on("data", (d) => chunks.push(d));
        res.on("end", () => {
          try {
            const body = Buffer.concat(chunks).toString("utf8");
            resolve(JSON.parse(body));
          } catch (e) {
            reject(e);
          }
        });
      })
      .on("error", reject);
  });
}

function providerFromModelId(modelId) {
  // OpenRouter model ids often look like "provider/model[:suffix]"
  const [provider] = String(modelId).split("/");
  return provider || "openrouter";
}

function toProviderModel(orModel) {
  // Map OpenRouter fields to unified DTO
  function normalizeCost(pricing) {
    if (!pricing || typeof pricing !== "object") return undefined;
    const p = pricing;
    const toPerMillion = (v) => {
      if (v == null) return undefined;
      const n = typeof v === "string" ? parseFloat(v) : Number(v);
      if (!isFinite(n)) return undefined;
      return Math.round(n * 1_000_000 * 1e6) / 1e6;
    };
    const input = toPerMillion(p.prompt ?? p.input);
    const output = toPerMillion(p.completion ?? p.output);
    const reasoning = toPerMillion(p.internal_reasoning ?? p.reasoning);
    const cache_read = toPerMillion(p.input_cache_read ?? p.cache_read);
    const cache_write = toPerMillion(p.input_cache_write ?? p.cache_write);
    const cost = {};
    if (input !== undefined) cost.input = input;
    if (output !== undefined) cost.output = output;
    if (reasoning !== undefined) cost.reasoning = reasoning;
    if (cache_read !== undefined) cost.cache_read = cache_read;
    if (cache_write !== undefined) cost.cache_write = cache_write;
    return Object.keys(cost).length ? cost : undefined;
  }

  const cost = normalizeCost(orModel.pricing || orModel.cost);
  return {
    id: orModel.id,
    name: orModel.name || orModel.id,
    description: orModel.description,
    attachment: !!orModel.attachment,
    reasoning: !!orModel.reasoning,
    temperature:
      orModel.temperature !== undefined ? !!orModel.temperature : undefined,
    tool_call: !!orModel.tool_call,
    knowledge: orModel.knowledge,
    created: orModel.created,
    release_date: orModel.release_date,
    last_updated: orModel.last_updated,
    modalities: orModel.modalities,
    open_weights: orModel.open_weights,
    cost,
    limit:
      orModel.limit || orModel.context_length || orModel.context
        ? { context: orModel.context_length || orModel.context }
        : undefined,
  };
}

async function main() {
  const url = "https://openrouter.ai/api/v1/models";
  const json = await fetchJson(url);
  const data = Array.isArray(json?.data) ? json.data : [];

  // Group by provider prefix
  const providers = new Map();
  for (const m of data) {
    const provider = providerFromModelId(m.id);
    const entry = providers.get(provider) || {
      id: provider,
      name: provider,
      api: "https://openrouter.ai/api/v1",
      doc: "https://openrouter.ai/models",
      env: ["OPENROUTER_API_KEY"],
      source: "openrouter",
      schemaVersion: 1,
      models: {},
    };
    entry.models[m.id] = toProviderModel(m);
    providers.set(provider, entry);
  }

  const baseDir = path.join(__dirname, "..", "src", "openrouter");
  const providersDir = path.join(baseDir, "providers");
  await fs.mkdir(providersDir, { recursive: true });

  const indexImports = [];
  const indexEntries = [];

  const keys = Array.from(providers.keys()).sort();
  for (const key of keys) {
    const providerInfo = providers.get(key);
    const fileBase = key.replace(/[^a-z0-9\-_.]/gi, "_");
    const varName = `${key.replace(/[^a-zA-Z0-9_]/g, "_")}Provider`;
    const body = JSON.stringify(providerInfo, null, 2);
    const ts = `export const ${varName} = ${body} as const;\nexport default ${varName};\n`;
    await fs.writeFile(path.join(providersDir, `${fileBase}.ts`), `${ts}\n`);
    indexImports.push(`import ${varName} from './providers/${fileBase}.js';`);
    indexEntries.push(`  ${JSON.stringify(key)}: ${varName},`);
  }

  const indexTs = `// Auto-generated by scripts/sync-openrouter.mjs
${indexImports.join("\n")}\n
export const openrouterProviders = {\n${indexEntries.join("\n")}\n} as const;\n`;
  await fs.writeFile(path.join(baseDir, "index.ts"), `${indexTs}\n`);
  console.log(`Wrote ${keys.length} OpenRouter provider files and index.ts`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
